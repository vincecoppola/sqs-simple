{
  "version": 3,
  "sources": [
    "sqs.js"
  ],
  "names": [
    "opts",
    "parseOptions",
    "sqs",
    "_debug",
    "debug",
    "queueName",
    "validateQueueName",
    "Error",
    "Attributes",
    "DelaySeconds",
    "delaySeconds",
    "toString",
    "VisibilityTimeout",
    "Number",
    "visibilityTimeout",
    "fifo",
    "FifoQueue",
    "ContentBasedDeduplication",
    "createQueue",
    "QueueName",
    "promise",
    "queueUrl",
    "QueueUrl",
    "getQueueAttributes",
    "AttributeNames",
    "queueArn",
    "QueueArn",
    "initQueue",
    "stats",
    "getQueueUrl",
    "result",
    "getQueueStats",
    "getQueueInfo",
    "url",
    "parse",
    "pathname",
    "slice",
    "purgeQueue",
    "deleteQueue",
    "msg",
    "totalDeleted",
    "start",
    "Date",
    "now",
    "receiveMessage",
    "MaxNumberOfMessages",
    "WaitTimeSeconds",
    "msgs",
    "Messages",
    "all",
    "map",
    "deleteMessage",
    "ReceiptHandle",
    "length",
    "emptyQueue",
    "_",
    "require",
    "SQS",
    "MSG_VERSION",
    "SQS_QUEUE_NAME_PATTERN",
    "assert",
    "EventEmitter",
    "test",
    "isFifoQueue",
    "_opts",
    "keys",
    "sqsConfig",
    "defaults",
    "waitTimeSeconds",
    "maxNumberOfMessages",
    "maxReceiveCount",
    "encodeMessage",
    "decodeMessage",
    "sequential",
    "region",
    "apiVersion",
    "includes",
    "u",
    "host",
    "protocol",
    "handler",
    "present",
    "missing",
    "filter",
    "key",
    "err",
    "join",
    "pick",
    "__encodeMsg",
    "input",
    "version",
    "data",
    "__decodeMsg",
    "JSON",
    "QueueSender",
    "requiredOpts",
    "opt",
    "body",
    "message",
    "MessageBody",
    "MessageGroupId",
    "sendMessage",
    "QueueListener",
    "running",
    "setTimeout",
    "emit",
    "__receiveMsg",
    "Array",
    "isArray",
    "__handleMsg",
    "x",
    "error",
    "underlyingErr",
    "underlyingStack",
    "stack",
    "msgId",
    "MessageId",
    "rh",
    "changetimeout",
    "newTimeout",
    "newSetting",
    "changeMessageVisibility",
    "outcome",
    "deleteMsg",
    "Body",
    "contentPreview",
    "changeTimeout",
    "module",
    "exports",
    "__sqsMsgStorageVersion"
  ],
  "mappings": "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",
  "file": "sqs.js",
  "sourceRoot": "../src",
  "sourcesContent": [
    "/**\n * A Queue backed by SQS\n */\n\nconst _ = require('lodash');\nconst debug = require('debug');\nconst url = require('url');\nconst SQS = require('aws-sdk').SQS;\n\n/**\n * The default internal version of the message payload\n */\nconst MSG_VERSION = 1;\nconst SQS_QUEUE_NAME_PATTERN = /^[a-zA-Z0-9_-]{1,80}$/;\n\nconst assert = require('assert');\n\nconst EventEmitter = require('events');\n\nfunction validateQueueName(queueName) {\n  if (queueName.length > 80 || !queueName.length) return false;\n  return SQS_QUEUE_NAME_PATTERN.test(queueName) || (\n    SQS_QUEUE_NAME_PATTERN.test(queueName.slice(0, -5)) && isFifoQueue(queueName)\n  );\n}\n\nfunction isFifoQueue(queueName) {\n  return queueName && queueName.slice(queueName.length - 5) === '.fifo';\n}\n\n/**\n * Parse out the options, sets defaults and allows\n * user to specify which options they expect\n */\nfunction parseOptions(_opts, keys) {\n  if (_opts.sqs && _opts.sqsConfig) {\n    throw new Error('If you provide SQS client, don\\'t provide SQS configuration');\n  }\n\n  let opts = _.defaults({}, _opts, {\n    fifo: false,\n    visibilityTimeout: 30,\n    waitTimeSeconds: 1,\n    maxNumberOfMessages: 1,\n    maxReceiveCount: 5,\n    encodeMessage: true,\n    decodeMessage: true,\n    sequential: false,\n    delaySeconds: 0,\n    sqsConfig: {\n      region: 'us-west-2',\n      apiVersion: '2012-11-15',\n    }\n  });\n\n  // Create the SQS object if we don't have one but we want one.\n  if (!opts.sqs && _.includes(keys, 'sqs')) {\n    assert(opts.sqsConfig.region, 'Must provide SQS Region');\n    opts.sqs = new SQS(opts.sqsConfig);\n  }\n\n  // Because lodash is weird, it assumes falsy values in a _.defaults means\n  // that it should not be set.\n  opts.decodeMessage = _opts.decodeMessage;\n  opts.encodeMessage = _opts.encodeMessage;\n  if (typeof opts.decodeMessage === 'undefined') {\n    opts.decodeMessage = true;\n  }\n  if (typeof opts.encodeMessage === 'undefined') {\n    opts.encodeMessage = true;\n  }\n\n  // If provided, a QueueUrl must be a valid URL\n  if (opts.queueUrl) {\n    let u = url.parse(opts.queueUrl);\n    if (!u.host || !u.protocol) {\n      throw new Error('Invalid QueueUrl provided');\n    }\n  }\n\n  // If provided, QueueName should be valid\n  if (opts.queueName) {\n    if (opts.fifo && !isFifoQueue(opts.queueName)) {\n      opts.queueName = opts.queueName + '.fifo';\n    }\n    if (!validateQueueName(opts.queueName)) {\n      throw new Error('Invalid Queue Name: ' + opts.queueName);\n    }\n  }\n\n  if (opts.handler && _.includes(keys, 'handler') && typeof opts.handler !== 'function') {\n    throw new Error('If provided, handler must be a promise-returning function');\n  }\n\n  let present = _.keys(opts);\n  let missing = keys.filter(key => !_.includes(present, key));\n\n  if (missing.length > 0) {\n    let err = new Error('Missing options: ' + missing.join(', '));\n    err.missing = missing;\n    err.present = present;\n    throw err;\n  }\n\n  return _.pick(opts, keys);\n}\n\n/**\n * Encode a key into the desired format\n */\nfunction __encodeMsg (input, version = MSG_VERSION) {\n  switch(version) {\n    case 1:\n      return JSON.stringify({\n        version: 1,\n        data: input,\n      })\n      break;\n    default:\n      throw new Error('Encoding for unknown version of message payload');\n  }\n}\n\n/**\n * Decode a message.  If we know how to get the data we want from a message\n * encoded with a different version we do\n */\nfunction __decodeMsg (input) {\n  let msg = JSON.parse(input);\n  switch (msg.version) {\n    case 1:\n      return msg.data;\n      break;\n    default:\n      throw new Error('Decoding unknown version of message payload');\n  }\n}\n\n/**\n * Initialize a queue. This function will overwrite existing VisibiltyTimeout and\n * RedrivePolicy attributes on the queues if they already exist.\n *\n * TODO: This function should check on error to see if the reason for the error\n * is the 60 between-delete-and-create api imposed limit is the error for\n * creation and if so, try again in 5 seconds up to a max of 65 seconds before\n * giving up\n */\nasync function initQueue (opts) {\n  opts = parseOptions(opts, [\n    'sqs',\n    'queueName',\n    'maxReceiveCount',\n    'visibilityTimeout',\n    'delaySeconds',\n    'fifo',\n  ]);\n\n  // Shorthand\n  let sqs = opts.sqs;\n\n  const _debug = debug('queue:initQueue:' + opts.queueName);\n\n  if (!validateQueueName(opts.queueName)) {\n    throw new Error('Invalid Queue Name: ' + opts.queueName);\n  }\n\n  const Attributes = {\n    // Bug in AWS-Sdk? the receiveMessage VisibiltyTimeout accepts strings\n    // but not here...\n    DelaySeconds: opts.delaySeconds.toString(),\n    VisibilityTimeout: Number(opts.visibilityTimeout).toString(),\n  };\n\n  if (opts.fifo) {\n    Attributes.FifoQueue = 'true';\n    Attributes.ContentBasedDeduplication = 'true';\n  }\n\n  // Now we'll create the queue\n  let queueUrl = (await sqs.createQueue({\n    QueueName: opts.queueName,\n    Attributes,\n  }).promise()).QueueUrl;\n\n  // Now we'll find the queue's ARN\n  let queueArn = (await sqs.getQueueAttributes({\n    QueueUrl: queueUrl,\n    AttributeNames: ['QueueArn'],\n  }).promise()).Attributes.QueueArn;\n  \n  _debug('created queue %s', queueUrl);\n\n  return {queueUrl, queueArn};\n}\n\n/**\n * Given a queueName, return some basic statistics about that queue\n */\nasync function getQueueStats(opts) {\n  opts = parseOptions(opts, ['sqs', 'queueName']);\n\n  let stats = [\n    'ApproximateNumberOfMessages',\n    'ApproximateNumberOfMessagesDelayed',\n    'ApproximateNumberOfMessagesNotVisible',\n    'DelaySeconds',\n    'VisibilityTimeout',\n  ];\n\n  let queueUrl = (await opts.sqs.getQueueUrl({\n    QueueName: opts.queueName,\n  }).promise()).QueueUrl;\n\n  let result = await opts.sqs.getQueueAttributes({\n    QueueUrl: queueUrl,\n    AttributeNames: stats,\n  }).promise();\n  return result.Attributes;\n}\n\n/**\n * Given a queueName, determine the queueUrl and queueArn\n */\nasync function getQueueInfo(opts) {\n  opts = parseOptions(opts, ['sqs', 'queueName']);\n\n  let queueUrl = (await opts.sqs.getQueueUrl({\n    QueueName: opts.queueName,\n  }).promise()).QueueUrl;\n\n  let queueArn = (await opts.sqs.getQueueAttributes({\n    QueueUrl: queueUrl,\n    AttributeNames: ['QueueArn'],\n  }).promise()).Attributes.QueueArn;\n\n  return {queueUrl, queueArn};\n}\n\n/**\n * Given a queueName, determine the queueUrl\n */\nasync function getQueueUrl(opts) {\n  opts = parseOptions(opts, ['sqs', 'queueName']);\n\n  return (await opts.sqs.getQueueUrl({\n    QueueName: opts.queueName,\n  }).promise()).QueueUrl;\n}\n\n\n/**\n * Use the correct API function to purge the queue of items.  This has the\n * unfortunate consequence of only being able to run once every 60 seconds on\n * the specified queue.\n * \n *\n * TODO: like initQueue, this should retry every 5s if the reason for failure is\n * that there was a previous purge in the last 60s.\n */\nasync function purgeQueue(opts) {\n  opts = parseOptions(opts, ['sqs', 'queueUrl']);\n  const _debug = debug('queue:purgeQueue:' + url.parse(opts.queueUrl).pathname.slice(1));\n\n  await opts.sqs.purgeQueue({QueueUrl: opts.queueUrl}).promise();\n  _debug('purged queue %s', opts.queueUrl);\n}\n\n/**\n * Delete a queue.  \n */\nasync function deleteQueue(opts) {\n  opts = parseOptions(opts, ['sqs', 'queueUrl']);\n  const _debug = debug('queue:deleteQueue:' + url.parse(opts.queueUrl).pathname.slice(1));\n\n  await opts.sqs.deleteQueue({QueueUrl: opts.queueUrl}).promise();\n  _debug('deleted queue %s', opts.queueUrl);\n}\n\n/**\n * Hack the system!  Basically, we want something for unit tests and the sort\n * to let us have an empty queue.  This function will try to receive messages.\n * It will go for 5s (5 calls to receiveMessage) or as long as there is more\n * than a single message returned by the API.\n *\n * This is a best effort only!\n *\n * TODO: Make the 5s count only since the first of a series of returns with\n * zero items in the return value.\n */\nasync function emptyQueue(opts) {\n  opts = parseOptions(opts, ['sqs', 'queueUrl']);\n  // shorthand\n  let sqs = opts.sqs;\n  let queueUrl = opts.queueUrl;\n\n  const _debug = debug('queue:emptyQueue:' + url.parse(queueUrl).pathname.slice(1));\n\n\n  let msg;\n  let totalDeleted = 0;\n\n  let start = Date.now();\n\n  do {\n    // We don't use the configuration from opts, since we're trying to empty\n    // the queue.  We want the default of 10 messages so we can kill them all,\n    // and we shouldn't need too much time to delete them \n    msg = await sqs.receiveMessage({\n      QueueUrl: queueUrl,\n      VisibilityTimeout: 4,\n      MaxNumberOfMessages: 10,\n      WaitTimeSeconds: 1,\n    }).promise();\n\n    let msgs = msg.Messages || [];\n    \n    // TODO: Use the batch version of this function\n    await Promise.all(msgs.map(msg => {\n      return sqs.deleteMessage({\n        QueueUrl: queueUrl,\n        ReceiptHandle: msg.ReceiptHandle,\n      }).promise();\n    }));\n    totalDeleted += msgs.length;\n    _debug('deleted %d msgs, %d total msgs', msgs.length, totalDeleted);\n  } while (msg.length > 0 || (Date.now() - start) < 5000);\n  // ^^^ We'll try to delete until there are no messages and we will try for at\n  // least 5 seconds.  This is for eventual consistency concerns\n  _debug('emptied queue %s (maybe!)', queueUrl);\n}\n\n\n/**\n * A QueueSender knows how to insert items into an SQS Queue.  The messages\n * given to the `.insert()` method should be in the format that the eventual\n * handler will be given.  The QueueSender will internally serialise this\n * payload, the QueueListener will deserialise the payload.\n */\nclass QueueSender {\n  constructor(opts) {\n    \n    // These are the options that a QueueListener\n    // must have\n    let requiredOpts = [\n      'sqs',\n      'queueUrl',\n      'encodeMessage',\n      'fifo',\n    ];\n\n    // Figure them out\n    opts = parseOptions(opts, requiredOpts);\n\n    // Now set them\n    for (let opt of requiredOpts) {\n      this[opt] = opts[opt];\n    }\n\n    // We want to make sure that debugging output is somewhat useful, so we'll\n    // include a little bit of info in each debug message.\n    this.debug = debug('queue:QueueSender:' + url.parse(opts.queueUrl).pathname.slice(1));\n  }\n\n  /**\n   * Insert a message into the Queue.  `msg` must be JSON serializable and must\n   * be a truthy value\n   */\n  async insert(msg) {\n    assert(typeof msg !== 'undefined');\n    let body;\n    if (this.encodeMessage) {\n      body = __encodeMsg(msg);\n    } else {\n      assert(typeof msg === 'string', 'msg body must be string');\n      body = msg;\n    }\n\n    const message = {\n      QueueUrl: this.queueUrl,\n      MessageBody: body,\n    };\n\n    if (this.fifo) message.MessageGroupId = '1';\n    \n    let result = await this.sqs.sendMessage(message).promise();\n\n    this.debug('inserted message');\n\n    return result;\n  }\n\n}\n\n\n/**\n * A QueueListener knows how to listen on an SQS queue for messages and run a\n * handler function on them.  The handler function is a promise-returning\n * function (await'd).  This handler function is passed in a deserialised\n * version of of the message given to the `QueueSender.insert()` method as its\n * first argument.  The second argument is a promise-returning function which\n * can be used to change the visibility time of the message directly.  If the\n * handler promise rejects, the message is immediately marked as a failed\n * receipt.  You do not need to call this second arugment function to mark a\n * failure, it's provided so that handlers can set longer timeouts if they\n * think that their payload might take longer than originally expected.\n *\n * This class is an event emitter.  The following events get emitted:\n *   - `starting` is emitted just before starting the polling loop.  Emitted\n *     without arguments\n *   - `stopped` after the last handler completes running. Emitted without\n *     arguments\n *   - `error` is emitted when an error occurs.  The firt arugment to the\n *     handler is the Error() object which caused the emission.  The second\n *     argument is a string specifying the type of error.  This string will\n *     be 'api', 'payload' or 'handler'.  An api error is an error running\n *     an underlying SQS Api.  A payload error is an encoding problem with\n *     the payload.  A handler error is an error which was caused by a\n *     handler returning a promise rejection.  A handler error means\n *     that the API and message encoding worked as normal.  I\n */\nclass QueueListener extends EventEmitter {\n  constructor(opts) {\n    super();\n    \n    // These are the options that a QueueListener\n    // must have\n    let requiredOpts = [\n      'sqs',\n      'queueUrl',\n      'visibilityTimeout',\n      'waitTimeSeconds',\n      'maxNumberOfMessages',\n      'handler',\n      'decodeMessage',\n      'sequential',\n    ];\n\n    // Figure them out\n    opts = parseOptions(opts, requiredOpts);\n\n    // Now set them\n    for (let opt of requiredOpts) {\n      this[opt] = opts[opt];\n    }\n\n    // We want to make sure that debugging output is somewhat useful, so we'll\n    // include a little bit of info in each debug message.\n    this.debug = debug('queue:QueueListener:' + url.parse(opts.queueUrl).pathname.slice(1));\n\n    // used to decide whether to launch another __receiveMsg() call\n    this.running = false;\n\n\n  }\n\n  /*\n   * Start listening on a queue\n   */\n  start() {\n    this.debug('starting listening to queue');\n    this.running = true;\n    // Using setTimeout instead of nextTick because we want this to happen\n    // after all the other jazz in the event loop happens, rather than starving\n    // it by always forcing it to happen before using nextTick\n    setTimeout(async () => {\n      this.emit('starting');\n      await this.__receiveMsg();\n    }, 0);\n  }\n\n  /**\n   * Stop listening on a queue.  Might not stop queue instantly\n   */\n  stop() {\n    this.running = false;\n    this.debug('stopping listening to queue');\n  }\n\n  /**\n   * Internal-only method which is the actual code that polls SQS and hands off\n   * the messages it received onto the handler of the class.  Since this method\n   * is *alway* called from a setTimeout handler, it's important for it to\n   * handle all errors.  This function *must* not be capable of rejecting since\n   * it's where all the later promise code chains off\n   *\n   * The __handleMsg() function should also take care of all of its own error\n   * situations... basically __receiveMsg() and __handleMsg() are fire and\n   * forget methods...  Here thar be dragons!\n   */\n  async __receiveMsg() {\n    let msg;\n    try {\n      msg = await this.sqs.receiveMessage({\n        QueueUrl: this.queueUrl,\n        MaxNumberOfMessages: this.maxNumberOfMessages,\n        WaitTimeSeconds: this.waitTimeSeconds,\n        VisibilityTimeout: this.visibilityTimeout,\n      }).promise();\n    } catch (err) {\n      this.emit('error', err, 'api');\n      return;\n    }\n\n    let msgs = [];\n    if (msg.Messages) {\n      if (!Array.isArray(msg.Messages)) {\n        this.emit('error', new Error('SQS Api returned non-list'), 'api');\n        return;\n      }\n      this.debug('received %d messages', msgs.length);\n      msgs = msg.Messages;\n    } else {\n      this.debug('received 0 messages');\n    }\n\n    // We never want this to actually throw.  The __handleMsg function should\n    // take care of emitting the error event\n    try {\n      if (this.sequential) {\n        for (let msg of msgs) {\n          await this.__handleMsg(msg);\n        }\n      } else {\n        await Promise.all(msgs.map(x => this.__handleMsg(x)));\n      }\n    } catch (err) {\n      let error = new Error('__handleMsg is rejecting when it ought not to.  ' +\n                    'This is a programming error in QueueListener.__handleMsg()');\n      error.underlyingErr = err;\n      error.underlyingStack = err.stack || '';\n      this.debug('This really should not happen... %j', error);\n      this.emit('error', error, 'api');\n    }\n\n    if (this.running) {\n      // Same as the call in .start(), but here we do a small timeout of 50ms\n      // just to make sure that we're not totally starving eveything\n      setTimeout(async () => {\n        await this.__receiveMsg();\n      }, 50);\n    } else {\n      this.emit('stopped');\n    }\n  }\n\n  /**\n   * Internal method for handling each received message.  This function *must*\n   * not throw because of the way that it's called.  It should emit 'error'\n   * events and return early as the method of showing an exceptional sitaution\n   *\n   * The control flow in this function should work like this:\n   * the closures should take care of emitting the events required.  The main\n   * function body itself should never throw.  Use return in the main function\n   * body to terminate the execution of this function\n   */\n  async __handleMsg(msg) {\n    let msgId = msg.MessageId;\n    let rh = msg.ReceiptHandle;\n    this.debug('handling message %s', msgId);\n\n    // This is passed into the handler to change the current visibility\n    // timeout.  This can be used to allow for a short initial visibility\n    // timeout.  The shorter initial timeout would be used for processing the\n    // message, but the handler should call this message with however long it\n    // thinks that it needs to process the message.  The `newTimeout` parameter\n    // is the number of seconds that the message should be visible after the\n    // call is made.\n    //\n    // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/SQS.html#changeMessageVisibility-property.\n    let changetimeout = async (newTimeout) => {\n      assert(typeof newTimeout === 'number');\n      assert(newTimeout >= 0);\n      // I suspect that the API doesn't honour a setting of 0, so using something simliar :(\n      let newSetting = newTimeout || 1;\n      try {\n        let outcome = await this.sqs.changeMessageVisibility({\n          QueueUrl: this.queueUrl,\n          ReceiptHandle: rh,\n          VisibilityTimeout: newSetting,\n        }).promise();\n        this.debug('message %s now expires %s (+%ds)', msgId, new Date(Date.now() + newSetting * 1000), newSetting);\n      } catch (err) {\n        this.debug('error changing message %s visibility', msgId);\n        this.debug(err);\n        this.emit('error', err, 'api');\n        throw new Error('Failed to change timeout');\n      }\n    }\n\n    // Delete this message\n    let deleteMsg = async () => {\n      try {\n        await this.sqs.deleteMessage({\n          QueueUrl: this.queueUrl,\n          ReceiptHandle: rh,\n        }).promise();\n        this.debug('removed message %s from queue', msgId);\n      } catch (err) {\n        this.debug('error deleting message %s visibility', msgId);\n        this.debug(err);\n        this.emit('error', err, 'api');\n      }\n    }\n\n    // Parse the message.\n    let body;\n    if (this.decodeMessage) {\n      try {\n        body = __decodeMsg(msg.Body);\n      } catch (err) {\n        this.emit('error', err, 'payload');\n        // Let's pretty print some debugging information\n        let contentPreview = msg.Body;\n        // not perfect, but meh, i don't care\n        if (contentPreview.length > 100) {\n          contentPreview = contentPreview.slice(0, 97) + '...';\n        }\n        this.debug('message %s has malformed payload, deleting: %s', msgId, contentPreview);\n\n        // We now know that this message isn't valid on this instance of\n        // QueueListener.  Since we might have a mixed pool of listeners and\n        // another one might be able to understand this, let's mark the message\n        // as a failure and put it back into the queue.  This is mainly to\n        // support gradual upgrades\n        try {\n          await changeTimeout(0);\n        } catch(err) { }\n        return;\n      }\n    } else {\n      body = msg.Body;\n    }\n\n    // Run the handler.  If the handler promise rejects, then we'll delete the\n    // message and return.  If the handler promise resolves, then we'll delete\n    // the message and return.  If the deletion on handler resolution or\n    // changetimeout on handler rejection failes, then we return then.\n    try {\n      await this.handler(body, changetimeout);\n      try {\n        await deleteMsg();\n      } catch(err) { }\n      this.debug('handler successfully processed message %s', msgId);\n      return;\n    } catch (err) {\n      debug('handler failed to process message %s', msgId);\n      try {\n        await changetimeout(0);\n      } catch(err) { } \n      this.emit('error', err, 'handler');\n      return;\n    }\n  }\n}\n\nmodule.exports = {\n  QueueSender,\n  QueueListener,\n  initQueue,\n  getQueueUrl,\n  getQueueStats,\n  purgeQueue,\n  emptyQueue,\n  deleteQueue,\n  __sqsMsgStorageVersion: MSG_VERSION,\n  __encodeMsg,\n  __decodeMsg,\n}\n"
  ]
}
